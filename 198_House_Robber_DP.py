# Time Complexity : O(n) [n = number of houses]
# 
# Space Complexity : O(n) [n = number of houses]
# 
# Did this code successfully run on Leetcode : Yes
# 
# Any problem you faced while coding this : No


# Your code here along with comments explaining your approach
# 1. Follow this approach to decide whether to rob the current house or not
#   1.1 Find the money amount that can be generated by robbing the previous house
#   1.2 Find the money amount that can be generated by robbing the current house and house previous to the previous of current house
#   1.3 The maxmimum of these two in the desired result
# 2. Create a memo list of length (n+1). Value at each index holds the maximum money that can be generated at that index.
# 3. In other words, let us assume we are at index 3. To get the max money value at this index, we take into consideration only the first three houses. The value at index 2(max money if there were only two houses) and 1(max money if there was only one house) can assist us
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:return 0
        if len(nums) == 1:return nums[0]
        memo = [0 for i in range(len(nums)+1)]
        memo[1] = nums[0]
        for i in range(1, len(nums)):
        	# nums[i] = Money from current house
        	# memo[i-1] = Money from house previous to the previous of current house
        	# memo[i] = Money from the previous house
            memo[i+1] = max(memo[i], nums[i] + memo[i-1])
        return memo[len(nums)]