//Using Recursion
//time complexity - O(2^n) - n is the amount
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(coins.length == 0)
            return 0;
        
        return helper(coins, 0 , amount , 0);
    }
    private int helper(int[] coins, int i , int amount , int mincoins) 
    {
        if(amount == 0 ) return mincoins;
        if(amount < 0 || i == coins.length) return -1;
        int case1 = helper(coins, i , amount - coins[i], mincoins + 1);
        // not choose
        int case2 = helper(coins, i + 1, amount - 0, mincoins);
        if(case1 == -1) return case2;
        if(case2 == -1) return case1;
	
	    return Math.min(case1 , case2);
    }
}

// using dp
//time complexity - O(m*n)
//space complexity - O(m*n)
class Solution {
    public int coinChange(int[] coins, int amount) {
        int m = coins.length;
        int n = amount;
        int[][] dp = new int[m+1][n+1];
        for(int j = 0 ; j < dp[0].length ; j++ )
        {
            dp[0][j] = 99999;
        }
        for(int i = 1 ; i< dp.length ; i++ )
        {
            for(int j = 1 ; j < dp[0].length ; j++)
            {
                if(j < coins[i - 1])
                {
                    dp[i][j] = dp[i-1][j];
                }
                else
                {
                    dp[i][j] = Math.min(dp[i-1][j] , 1 + dp[i][j - coins[i - 1]]);
                }
            }
        }
        if(dp[m][n] >= 99999) return -1;
        return dp[m][n];
    }
    
}
