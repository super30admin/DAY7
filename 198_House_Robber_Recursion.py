# Time Complexity : O(2 ^ n) [n = number of houses]
# 
# Space Complexity : O(2 ^ n) [Total 2^n function calls, so it uses stack space]
# 
# Did this code successfully run on Leetcode : Partially(TLE)
# 
# Any problem you faced while coding this : No


# Your code here along with comments explaining your approach
# 1. Follow this approach to decide whether to rob the current house or not
#   1.1 Find the money amount that can be generated by robbing the previous house
#   1.2 Find the money amount that can be generated by robbing the current house and house previous to the previous of current house
#   1.3 The maxmimum of these two in the desired result
class Solution:
    def robRecursion(self, nums, i):
        if i < 0:
            return 0
        if i == 0:
            return nums[0]
        # nums[i] = Money from current house
        # self.robRecursion(nums, i-2) = Money from house previous to the previous of current house
        # self.robRecursion(nums, i-1) = Money from the previous house
        return max(nums[i]+self.robRecursion(nums, i-2) , self.robRecursion(nums, i-1))
        
    def rob(self, nums: List[int]) -> int:
        if not nums:return 0
        if len(nums) == 1:return nums[0]
        return self.robRecursion(nums, len(nums)-1)