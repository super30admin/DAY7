#Problem 1

Exponential

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if coins == None or len(coins) == 0:
            return -1

        result = self.recurse(coins, 0, amount, 0)

        return result
    

    def recurse(self, coins: List[int], index: int, amount: int, numCoins: int) -> int:

        #base case

        if index == len(coins) or amount < 0:
            return -1
        
        if amount == 0:
            return numCoins

        #logic
        #don't choose case (0)
        case1 = self.recurse(coins, index + 1, amount, numCoins)

        #chose case (1)

        case2 = self.recurse(coins, index, amount - coins[index], numCoins + 1)
        if case1 == -1:
            return case2
        if case2 == -1:
            return case1
        return min(case1, case2)


DP

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if coins == None or len(coins) == 0:
            return -1
        n = len(coins)
        dp = [[0] * (amount + 1)] * (n + 1)

        for i in range(1, amount + 1):
            dp[0][i] = amount + 1
        
        for i in range(1, n + 1):
            for j in range(amount + 1):
                if j < coins[i - 1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = min(dp[i-1][j] , dp[i][j - coins[i-1]] + 1)
        if dp[n][amount] == amount + 1:
            return -1

        return dp[n][amount]


#Problem 2

Exponential

class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == None or len(nums) == 0:
            return -1
        
        result = self.recurse(nums, 0, 0)

        return result

    def recurse(self, nums: List[int], index: int, amountRobbed: int) -> int:
        #base case

        if index >= len(nums):
            return amountRobbed

        #logic
        #don't chose case (0)
        case1 = self.recurse(nums, index + 1, amountRobbed)

        #chose case (1)
        case2 = self.recurse(nums, index + 2, amountRobbed + nums[index])

        return max(case1, case2)

DP

class Solution:
    def rob(self, nums: List[int]) -> int:
        if nums == None or len(nums) == 0:
            return 0

        n = len(nums)

        dp = [[0 for i in range(2)] for j in range(n)]
        dp[0][1] = nums[0]

        for i in range(1,n):
            dp[i][0] = max(dp[i-1][1], dp[i-1][0])
            dp[i][1] = nums[i] + dp[i-1][0]
        
        return max(dp[n-1][0], dp[n-1][1])